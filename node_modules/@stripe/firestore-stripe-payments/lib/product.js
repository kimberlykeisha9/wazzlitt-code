/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { collection, doc, getDoc, getDocs, getFirestore, limit, query, where, } from "@firebase/firestore";
import { StripePaymentsError } from "./init";
import { checkNonEmptyString } from "./utils";
/**
 * Retrieves a Stripe product from the database.
 *
 * @param payments - A valid {@link StripePayments} object.
 * @param productId - ID of the product to retrieve.
 * @param options - A set of options to customize the behavior.
 * @returns Resolves with a Stripe Product object if found. Rejects if the specified product ID
 *  does not exist.
 */
export function getProduct(payments, productId, options) {
    checkNonEmptyString(productId, "productId must be a non-empty string.");
    const dao = getOrInitProductDAO(payments);
    return dao.getProduct(productId).then((product) => {
        if (options === null || options === void 0 ? void 0 : options.includePrices) {
            return getProductWithPrices(dao, product);
        }
        return product;
    });
}
/**
 * Retrieves a Stripe product from the database.
 *
 * @param payments - A valid {@link StripePayments} object.
 * @param productId - ID of the product to retrieve.
 * @param options - A set of options to customize the behavior.
 * @returns Resolves with an array of Stripe Product objects. May be empty.
 */
export function getProducts(payments, options) {
    const dao = getOrInitProductDAO(payments);
    const _a = options !== null && options !== void 0 ? options : {}, { includePrices } = _a, rest = __rest(_a, ["includePrices"]);
    return dao.getProducts(rest).then((products) => {
        if (includePrices) {
            const productsWithPrices = products.map((product) => getProductWithPrices(dao, product));
            return Promise.all(productsWithPrices);
        }
        return products;
    });
}
function getProductWithPrices(dao, product) {
    return __awaiter(this, void 0, void 0, function* () {
        const prices = yield dao.getPrices(product.id);
        return Object.assign(Object.assign({}, product), { prices });
    });
}
/**
 * Retrieves a Stripe price from the database.
 *
 * @param payments - A valid {@link StripePayments} object.
 * @param productId - ID of the product to which the price belongs.
 * @param priceId - ID of the price to retrieve.
 * @returns Resolves with a Stripe Price object if found. Rejects if the specified
 *   product ID or the price ID does not exist.
 */
export function getPrice(payments, productId, priceId) {
    checkNonEmptyString(productId, "productId must be a non-empty string.");
    checkNonEmptyString(priceId, "priceId must be a non-empty string.");
    const dao = getOrInitProductDAO(payments);
    return dao.getPrice(productId, priceId);
}
/**
 * Retrieves all Stripe prices associated with the specified product.
 *
 * @param payments - A valid {@link StripePayments} object.
 * @param productId - ID of the product to which the prices belong.
 * @returns Resolves with an array of Stripe Price objects. Rejects if the specified
 *   product ID does not exist. If the product exists, but doesn't have any prices, resolves
 *   with the empty array.
 */
export function getPrices(payments, productId) {
    checkNonEmptyString(productId, "productId must be a non-empty string.");
    const dao = getOrInitProductDAO(payments);
    return dao.getPrices(productId, { assertProduct: true });
}
const PRODUCT_CONVERTER = {
    toFirestore: () => {
        throw new Error("Not implemented for readonly Product type.");
    },
    fromFirestore: (snapshot) => {
        return Object.assign(Object.assign({}, snapshot.data()), { id: snapshot.id, prices: [] });
    },
};
const PRICE_CONVERTER = {
    toFirestore: () => {
        throw new Error("Not implemented for readonly Price type.");
    },
    fromFirestore: (snapshot) => {
        const data = snapshot.data();
        return Object.assign(Object.assign({}, data), { id: snapshot.id, product: snapshot.ref.parent.parent.id });
    },
};
class FirestoreProductDAO {
    constructor(app, productsCollection) {
        this.productsCollection = productsCollection;
        this.firestore = getFirestore(app);
    }
    getProduct(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const snap = yield this.getProductSnapshotIfExists(productId);
            return snap.data();
        });
    }
    getProducts(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const querySnap = yield this.getProductSnapshots(options);
            const products = [];
            querySnap.forEach((snap) => {
                products.push(snap.data());
            });
            return products;
        });
    }
    getPrice(productId, priceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const snap = yield this.getPriceSnapshotIfExists(productId, priceId);
            return snap.data();
        });
    }
    getPrices(productId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options === null || options === void 0 ? void 0 : options.assertProduct) {
                yield this.getProductSnapshotIfExists(productId);
            }
            const querySnap = yield this.getPriceSnapshots(productId);
            const prices = [];
            querySnap.forEach((snap) => {
                prices.push(snap.data());
            });
            return prices;
        });
    }
    getProductSnapshotIfExists(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const productRef = doc(this.firestore, this.productsCollection, productId).withConverter(PRODUCT_CONVERTER);
            const snapshot = yield this.queryFirestore(() => getDoc(productRef));
            if (!snapshot.exists()) {
                throw new StripePaymentsError("not-found", `No product found with the ID: ${productId}`);
            }
            return snapshot;
        });
    }
    getProductSnapshots(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let productsQuery = collection(this.firestore, this.productsCollection).withConverter(PRODUCT_CONVERTER);
            const constraints = [];
            if (options === null || options === void 0 ? void 0 : options.activeOnly) {
                constraints.push(where("active", "==", true));
            }
            if (options === null || options === void 0 ? void 0 : options.where) {
                for (const filter of options.where) {
                    constraints.push(where(...filter));
                }
            }
            if (typeof (options === null || options === void 0 ? void 0 : options.limit) !== "undefined") {
                constraints.push(limit(options.limit));
            }
            return yield this.queryFirestore(() => {
                if (constraints.length > 0) {
                    productsQuery = query(productsQuery, ...constraints);
                }
                return getDocs(productsQuery);
            });
        });
    }
    getPriceSnapshotIfExists(productId, priceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const priceRef = doc(this.firestore, this.productsCollection, productId, "prices", priceId).withConverter(PRICE_CONVERTER);
            const snapshot = yield this.queryFirestore(() => getDoc(priceRef));
            if (!snapshot.exists()) {
                throw new StripePaymentsError("not-found", `No price found with the product ID: ${productId} and price ID: ${priceId}`);
            }
            return snapshot;
        });
    }
    getPriceSnapshots(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const pricesCollection = collection(this.firestore, this.productsCollection, productId, "prices").withConverter(PRICE_CONVERTER);
            return yield this.queryFirestore(() => getDocs(pricesCollection));
        });
    }
    queryFirestore(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fn();
            }
            catch (error) {
                throw new StripePaymentsError("internal", "Unexpected error while querying Firestore", error);
            }
        });
    }
}
const PRODUCT_DAO_KEY = "product-dao";
function getOrInitProductDAO(payments) {
    let dao = payments.getComponent(PRODUCT_DAO_KEY);
    if (!dao) {
        dao = new FirestoreProductDAO(payments.app, payments.productsCollection);
        setProductDAO(payments, dao);
    }
    return dao;
}
/**
 * Internal API for registering a {@link ProductDAO} instance with {@link StripePayments}. Exported
 * for testing.
 *
 * @internal
 */
export function setProductDAO(payments, dao) {
    payments.setComponent(PRODUCT_DAO_KEY, dao);
}
//# sourceMappingURL=product.js.map