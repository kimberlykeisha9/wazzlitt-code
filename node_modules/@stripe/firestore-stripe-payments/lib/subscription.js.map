{"version":3,"file":"subscription.js","sourceRoot":"","sources":["../src/subscription.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from \"@firebase/app\";\nimport {\n  collection,\n  CollectionReference,\n  doc,\n  DocumentChange,\n  DocumentData,\n  DocumentReference,\n  DocumentSnapshot,\n  Firestore,\n  FirestoreDataConverter,\n  FirestoreError,\n  getDoc,\n  getDocs,\n  getFirestore,\n  onSnapshot,\n  query,\n  Query,\n  QueryDocumentSnapshot,\n  QuerySnapshot,\n  Timestamp,\n  where,\n} from \"@firebase/firestore\";\nimport { StripePayments, StripePaymentsError } from \"./init\";\nimport { getCurrentUser, getCurrentUserSync } from \"./user\";\nimport { checkNonEmptyArray, checkNonEmptyString } from \"./utils\";\n\n/**\n * Interface of a Stripe Subscription stored in the app database.\n */\nexport interface Subscription {\n  /**\n   * A future date in UTC format at which the subscription will automatically get canceled.\n   */\n  readonly cancel_at: string | null;\n\n  /**\n   * If `true`, the subscription has been canceled by the user and will be deleted at the end\n   * of the billing period.\n   */\n  readonly cancel_at_period_end: boolean;\n\n  /**\n   * If the subscription has been canceled, the date of that cancellation as a UTC timestamp.\n   * If the subscription was canceled with {@link Subscription.cancel_at_period_end}, this field\n   * will still reflect the date of the initial cancellation request, not the end of the\n   * subscription period when the subscription is automatically moved to a canceled state.\n   */\n  readonly canceled_at: string | null;\n\n  /**\n   * The date when the subscription was created as a UTC timestamp.\n   */\n  readonly created: string;\n\n  /**\n   * End of the current period that the subscription has been invoiced for as a UTC timestamp.\n   * At the end of the period, a new invoice will be created.\n   */\n  readonly current_period_end: string;\n\n  /**\n   * Start of the current period that the subscription has been invoiced for as a UTC timestamp.\n   */\n  readonly current_period_start: string;\n\n  /**\n   * If the subscription has ended, the date the subscription ended as a UTC timestamp.\n   */\n  readonly ended_at: string | null;\n\n  /**\n   * Unique Stripe subscription ID.\n   */\n  readonly id: string;\n\n  /**\n   * Set of extra key-value pairs attached to the subscription object.\n   */\n  readonly metadata: { [name: string]: string };\n\n  /**\n   * Stripe price ID associated with this subscription.\n   */\n  readonly price: string;\n\n  /**\n   * Array of product ID and price ID pairs. If multiple recurring prices were provided to the\n   * checkout session (e.g. via `lineItems`) this array holds all recurring prices for this\n   * subscription. The first element of this array always corresponds to the\n   * {@link Subscription.price} and {@link Subscription.product} fields on the subscription.\n   */\n  readonly prices: Array<{ product: string; price: string }>;\n\n  /**\n   * Stripe product ID associated with this subscription.\n   */\n  readonly product: string;\n\n  /**\n   * Quantity of items purchased with this subscription.\n   */\n  readonly quantity: number | null;\n\n  /**\n   * The Firebae role that can be assigned to the user with this subscription.\n   */\n  readonly role: string | null;\n\n  /**\n   * The status of the subscription object\n   */\n  readonly status: SubscriptionStatus;\n\n  /**\n   * A link to the subscription in the Stripe dashboard.\n   */\n  readonly stripe_link: string;\n\n  /**\n   * If the subscription has a trial, the end date of that trial as a UTC timestamp.\n   */\n  readonly trial_end: string | null;\n\n  /**\n   * If the subscription has a trial, the start date of that trial as a UTC timestamp.\n   */\n  readonly trial_start: string | null;\n\n  /**\n   * Firebase Auth UID of the user that created the subscription.\n   */\n  readonly uid: string;\n\n  readonly [propName: string]: any;\n}\n\n/**\n * Possible states a subscription can be in.\n */\nexport type SubscriptionStatus =\n  | \"active\"\n  | \"canceled\"\n  | \"incomplete\"\n  | \"incomplete_expired\"\n  | \"past_due\"\n  | \"trialing\"\n  | \"unpaid\";\n\n/**\n * Retrieves an existing Stripe subscription for the currently signed in user from the database.\n *\n * @param payments - A valid {@link StripePayments} object.\n * @param subscriptionId - ID of the subscription to retrieve.\n * @returns Resolves with a Subscription object if found. Rejects if the specified subscription ID\n *  does not exist, or if the user is not signed in.\n */\nexport function getCurrentUserSubscription(\n  payments: StripePayments,\n  subscriptionId: string\n): Promise<Subscription> {\n  checkNonEmptyString(\n    subscriptionId,\n    \"subscriptionId must be a non-empty string.\"\n  );\n  return getCurrentUser(payments).then((uid: string) => {\n    const dao: SubscriptionDAO = getOrInitSubscriptionDAO(payments);\n    return dao.getSubscription(uid, subscriptionId);\n  });\n}\n\n/**\n * Optional parameters for the {@link getCurrentUserSubscriptions} function.\n */\nexport interface GetSubscriptionsOptions {\n  /**\n   * Specify one or more subscription status values to retrieve. When set only the subscriptions\n   * with the given status are returned.\n   */\n  status?: SubscriptionStatus | SubscriptionStatus[];\n}\n\n/**\n * Retrieves existing Stripe subscriptions for the currently signed in user from the database.\n *\n * @param payments - A valid {@link StripePayments} object.\n * @param options - A set of options to customize the behavior.\n * @returns Resolves with an array of Stripe subscriptions. May be empty.\n */\nexport function getCurrentUserSubscriptions(\n  payments: StripePayments,\n  options?: GetSubscriptionsOptions\n): Promise<Subscription[]> {\n  const queryOptions: { status?: SubscriptionStatus[] } = {};\n  if (typeof options?.status !== \"undefined\") {\n    queryOptions.status = getStatusAsArray(options.status);\n  }\n\n  return getCurrentUser(payments).then((uid: string) => {\n    const dao: SubscriptionDAO = getOrInitSubscriptionDAO(payments);\n    return dao.getSubscriptions(uid, queryOptions);\n  });\n}\n\n/**\n * Different types of changes that may occur on a subscription object.\n */\nexport type SubscriptionChangeType = \"added\" | \"modified\" | \"removed\";\n\n/**\n * Represents the current state of a set of subscriptions owned by a user.\n */\nexport interface SubscriptionSnapshot {\n  /**\n   * A list of all currently available subscriptions ordered by the subscription ID. Empty\n   * if no subscriptions are available.\n   */\n  subscriptions: Subscription[];\n\n  /**\n   * The list of changes in the subscriptions since the last snapshot.\n   */\n  changes: Array<{\n    type: SubscriptionChangeType;\n    subscription: Subscription;\n  }>;\n\n  /**\n   * Number of currently available subscriptions. This is same as the length of the\n   * `subscriptions` array in the snapshot.\n   */\n  size: number;\n\n  /**\n   * True if there are no subscriptions available. False whenever at least one subscription is\n   * present. When True, the `subscriptions` array is empty, and the `size` is 0.\n   */\n  empty: boolean;\n}\n\n/**\n * Registers a listener to receive subscription update events for the currently signed in\n * user. If the user is not signed in throws an `unauthenticated` error, and no listener is\n * registered.\n *\n * Upon successful registration, the `onUpdate` callback will fire once with\n * the current state of all the subscriptions. From then onwards, each update to a subscription\n * will fire the `onUpdate` callback with the latest state of the subscriptions.\n *\n * @param payments - A valid {@link StripePayments} object.\n * @param onUpdate - A callback that will fire whenever the current user's subscriptions\n *   are updated.\n * @param onError - A callback that will fire whenever an error occurs while listening to\n *   subscription updates.\n * @returns A function that can be called to cancel and unregister the listener.\n */\nexport function onCurrentUserSubscriptionUpdate(\n  payments: StripePayments,\n  onUpdate: (snapshot: SubscriptionSnapshot) => void,\n  onError?: (error: StripePaymentsError) => void\n): () => void {\n  const uid: string = getCurrentUserSync(payments);\n  const dao: SubscriptionDAO = getOrInitSubscriptionDAO(payments);\n  return dao.onSubscriptionUpdate(uid, onUpdate, onError);\n}\n\nfunction getStatusAsArray(\n  status: SubscriptionStatus | SubscriptionStatus[]\n): SubscriptionStatus[] {\n  if (typeof status === \"string\") {\n    return [status];\n  }\n\n  checkNonEmptyArray(status, \"status must be a non-empty array.\");\n  return status;\n}\n\n/**\n * Internal interface for all database interactions pertaining to Stripe subscriptions. Exported\n * for testing.\n *\n * @internal\n */\nexport interface SubscriptionDAO {\n  getSubscription(uid: string, subscriptionId: string): Promise<Subscription>;\n  getSubscriptions(\n    uid: string,\n    options?: { status?: SubscriptionStatus[] }\n  ): Promise<Subscription[]>;\n  onSubscriptionUpdate(\n    uid: string,\n    onUpdate: (snapshot: SubscriptionSnapshot) => void,\n    onError?: (error: StripePaymentsError) => void\n  ): () => void;\n}\n\nconst SUBSCRIPTION_CONVERTER: FirestoreDataConverter<Subscription> = {\n  toFirestore: () => {\n    throw new Error(\"Not implemented for readonly Subscription type.\");\n  },\n  fromFirestore: (snapshot: QueryDocumentSnapshot): Subscription => {\n    const data: DocumentData = snapshot.data();\n    const refs: DocumentReference[] = data.prices;\n    const prices: Array<{ product: string; price: string }> = refs.map(\n      (priceRef: DocumentReference) => {\n        return {\n          product: priceRef.parent.parent!.id,\n          price: priceRef.id,\n        };\n      }\n    );\n\n    return {\n      cancel_at: toNullableUTCDateString(data.cancel_at),\n      cancel_at_period_end: data.cancel_at_period_end,\n      canceled_at: toNullableUTCDateString(data.canceled_at),\n      created: toUTCDateString(data.created),\n      current_period_start: toUTCDateString(data.current_period_start),\n      current_period_end: toUTCDateString(data.current_period_end),\n      ended_at: toNullableUTCDateString(data.ended_at),\n      id: snapshot.id,\n      metadata: data.metadata ?? {},\n      price: (data.price as DocumentReference).id,\n      prices,\n      product: (data.product as DocumentReference).id,\n      quantity: data.quantity ?? null,\n      role: data.role ?? null,\n      status: data.status,\n      stripe_link: data.stripeLink,\n      trial_end: toNullableUTCDateString(data.trial_end),\n      trial_start: toNullableUTCDateString(data.trial_start),\n      uid: snapshot.ref.parent.parent!.id,\n    };\n  },\n};\n\nconst SUBSCRIPTIONS_COLLECTION = \"subscriptions\" as const;\n\nfunction toNullableUTCDateString(timestamp: Timestamp | null): string | null {\n  if (timestamp === null) {\n    return null;\n  }\n\n  return toUTCDateString(timestamp);\n}\n\nfunction toUTCDateString(timestamp: Timestamp): string {\n  return timestamp.toDate().toUTCString();\n}\n\nclass FirestoreSubscriptionDAO implements SubscriptionDAO {\n  private readonly firestore: Firestore;\n\n  constructor(app: FirebaseApp, private readonly customersCollection: string) {\n    this.firestore = getFirestore(app);\n  }\n\n  public async getSubscription(\n    uid: string,\n    subscriptionId: string\n  ): Promise<Subscription> {\n    const snap: QueryDocumentSnapshot<Subscription> =\n      await this.getSubscriptionSnapshotIfExists(uid, subscriptionId);\n    return snap.data();\n  }\n\n  public async getSubscriptions(\n    uid: string,\n    options?: { status?: SubscriptionStatus[] }\n  ): Promise<Subscription[]> {\n    const querySnap: QuerySnapshot<Subscription> =\n      await this.getSubscriptionSnapshots(uid, options?.status);\n    const subscriptions: Subscription[] = [];\n    querySnap.forEach((snap: QueryDocumentSnapshot<Subscription>) => {\n      subscriptions.push(snap.data());\n    });\n\n    return subscriptions;\n  }\n\n  public onSubscriptionUpdate(\n    uid: string,\n    onUpdate: (snapshot: SubscriptionSnapshot) => void,\n    onError?: (error: StripePaymentsError) => void\n  ): () => void {\n    const subscriptions: CollectionReference<Subscription> = collection(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      SUBSCRIPTIONS_COLLECTION\n    ).withConverter(SUBSCRIPTION_CONVERTER);\n    return onSnapshot(\n      subscriptions,\n      (querySnap: QuerySnapshot<Subscription>) => {\n        const snapshot: SubscriptionSnapshot = {\n          subscriptions: [],\n          changes: [],\n          size: querySnap.size,\n          empty: querySnap.empty,\n        };\n        querySnap.forEach((snap: QueryDocumentSnapshot<Subscription>) => {\n          snapshot.subscriptions.push(snap.data());\n        });\n        querySnap\n          .docChanges()\n          .forEach((change: DocumentChange<Subscription>) => {\n            snapshot.changes.push({\n              type: change.type,\n              subscription: change.doc.data(),\n            });\n          });\n\n        onUpdate(snapshot);\n      },\n      (err: FirestoreError) => {\n        if (onError) {\n          const arg: StripePaymentsError = new StripePaymentsError(\n            \"internal\",\n            `Error while listening to database updates: ${err.message}`,\n            err\n          );\n          onError(arg);\n        }\n      }\n    );\n  }\n\n  private async getSubscriptionSnapshotIfExists(\n    uid: string,\n    subscriptionId: string\n  ): Promise<QueryDocumentSnapshot<Subscription>> {\n    const subscriptionRef: DocumentReference<Subscription> = doc(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      SUBSCRIPTIONS_COLLECTION,\n      subscriptionId\n    ).withConverter(SUBSCRIPTION_CONVERTER);\n    const snapshot: DocumentSnapshot<Subscription> = await this.queryFirestore(\n      () => getDoc(subscriptionRef)\n    );\n    if (!snapshot.exists()) {\n      throw new StripePaymentsError(\n        \"not-found\",\n        `No subscription found with the ID: ${subscriptionId} for user: ${uid}`\n      );\n    }\n\n    return snapshot;\n  }\n\n  private async getSubscriptionSnapshots(\n    uid: string,\n    status?: SubscriptionStatus[]\n  ): Promise<QuerySnapshot<Subscription>> {\n    let subscriptionsQuery: Query<Subscription> = collection(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      SUBSCRIPTIONS_COLLECTION\n    ).withConverter(SUBSCRIPTION_CONVERTER);\n    if (status) {\n      subscriptionsQuery = query(\n        subscriptionsQuery,\n        where(\"status\", \"in\", status)\n      );\n    }\n\n    return await this.queryFirestore(() => getDocs(subscriptionsQuery));\n  }\n\n  private async queryFirestore<T>(fn: () => Promise<T>): Promise<T> {\n    try {\n      return await fn();\n    } catch (error) {\n      throw new StripePaymentsError(\n        \"internal\",\n        \"Unexpected error while querying Firestore\",\n        error\n      );\n    }\n  }\n}\n\nconst SUBSCRIPTION_DAO_KEY = \"subscription-dao\" as const;\n\nfunction getOrInitSubscriptionDAO(payments: StripePayments): SubscriptionDAO {\n  let dao: SubscriptionDAO | null =\n    payments.getComponent<SubscriptionDAO>(SUBSCRIPTION_DAO_KEY);\n  if (!dao) {\n    dao = new FirestoreSubscriptionDAO(\n      payments.app,\n      payments.customersCollection\n    );\n    setSubscriptionDAO(payments, dao);\n  }\n\n  return dao;\n}\n\n/**\n * Internal API for registering a {@link SubscriptionDAO} instance with {@link StripePayments}.\n * Exported for testing.\n *\n * @internal\n */\nexport function setSubscriptionDAO(\n  payments: StripePayments,\n  dao: SubscriptionDAO\n): void {\n  payments.setComponent(SUBSCRIPTION_DAO_KEY, dao);\n}\n"]}