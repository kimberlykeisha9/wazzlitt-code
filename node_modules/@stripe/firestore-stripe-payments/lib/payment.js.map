{"version":3,"file":"payment.js","sourceRoot":"","sources":["../src/payment.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from \"@firebase/app\";\nimport {\n  collection,\n  CollectionReference,\n  doc,\n  DocumentChange,\n  DocumentData,\n  DocumentReference,\n  DocumentSnapshot,\n  Firestore,\n  FirestoreDataConverter,\n  FirestoreError,\n  getDoc,\n  getDocs,\n  getFirestore,\n  onSnapshot,\n  query,\n  Query,\n  QueryDocumentSnapshot,\n  QuerySnapshot,\n  where,\n} from \"@firebase/firestore\";\nimport { StripePayments, StripePaymentsError } from \"./init\";\nimport { getCurrentUser, getCurrentUserSync } from \"./user\";\nimport { checkNonEmptyArray, checkNonEmptyString } from \"./utils\";\n\n/**\n * Interface of a Stripe payment stored in the app database.\n */\nexport interface Payment {\n  /**\n   * Amount intended to be collected by this payment. A positive integer representing how much\n   * to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge\n   * Â¥100, a zero-decimal currency). The minimum amount is $0.50 US or equivalent in charge\n   * currency. The amount value supports up to eight digits (e.g., a value of 99999999 for a\n   * USD charge of $999,999.99).\n   */\n  readonly amount: number;\n\n  /**\n   * Amount that can be captured from this payment.\n   */\n  readonly amount_capturable: number;\n\n  /**\n   * Amount that was collected by this payment.\n   */\n  readonly amount_received: number;\n\n  /**\n   * The date when the payment was created as a UTC timestamp.\n   */\n  readonly created: string;\n\n  /**\n   * Three-letter ISO currency code, in lowercase. Must be a supported currency.\n   */\n  readonly currency: string;\n\n  /**\n   * ID of the Customer this payment belongs to, if one exists. Payment methods attached\n   * to other Customers cannot be used with this payment.\n   */\n  readonly customer: string | null;\n\n  /**\n   * An arbitrary string attached to the object. Often useful for displaying to users.\n   */\n  readonly description: string | null;\n\n  /**\n   * Unique Stripe payment ID.\n   */\n  readonly id: string;\n\n  /**\n   * ID of the invoice that created this payment, if it exists.\n   */\n  readonly invoice: string | null;\n\n  /**\n   * Set of key-value pairs that you can attach to an object. This can be useful for storing\n   * additional information about the object in a structured format.\n   */\n  readonly metadata: { [name: string]: string };\n\n  /**\n   * The list of payment method types (e.g. card) that this payment is allowed to use.\n   */\n  readonly payment_method_types: string[];\n\n  /**\n   * Array of product ID and price ID pairs.\n   */\n  readonly prices: Array<{ product: string; price: string }>;\n\n  /**\n   * Status of this payment.\n   */\n  readonly status: PaymentStatus;\n\n  /**\n   * Firebase Auth UID of the user that created the payment.\n   */\n  readonly uid: string;\n\n  readonly [propName: string]: any;\n}\n\n/**\n * Possible states a payment can be in.\n */\nexport type PaymentStatus =\n  | \"requires_payment_method\"\n  | \"requires_confirmation\"\n  | \"requires_action\"\n  | \"processing\"\n  | \"requires_capture\"\n  | \"cancelled\"\n  | \"succeeded\";\n\n/**\n * Retrieves an existing Stripe payment for the currently signed in user from the database.\n *\n * @param payments - A valid {@link StripePayments} object.\n * @param subscriptionId - ID of the payment to retrieve.\n * @returns Resolves with a Payment object if found. Rejects if the specified payment ID\n *  does not exist, or if the user is not signed in.\n */\nexport function getCurrentUserPayment(\n  payments: StripePayments,\n  paymentId: string\n): Promise<Payment> {\n  checkNonEmptyString(paymentId, \"paymentId must be a non-empty string.\");\n  return getCurrentUser(payments).then((uid: string) => {\n    const dao: PaymentDAO = getOrInitPaymentDAO(payments);\n    return dao.getPayment(uid, paymentId);\n  });\n}\n\n/**\n * Optional parameters for the {@link getCurrentUserPayments} function.\n */\nexport interface GetPaymentsOptions {\n  /**\n   * Specify one or more payment status values to retrieve. When set only the payments\n   * with the given status are returned.\n   */\n  status?: PaymentStatus | PaymentStatus[];\n}\n\nexport function getCurrentUserPayments(\n  payments: StripePayments,\n  options?: GetPaymentsOptions\n): Promise<Payment[]> {\n  const queryOptions: { status?: PaymentStatus[] } = {};\n  if (typeof options?.status !== \"undefined\") {\n    queryOptions.status = getStatusAsArray(options.status);\n  }\n\n  return getCurrentUser(payments).then((uid: string) => {\n    const dao: PaymentDAO = getOrInitPaymentDAO(payments);\n    return dao.getPayments(uid, queryOptions);\n  });\n}\n\n/**\n * Different types of changes that may occur on a payment object.\n */\nexport type PaymentChangeType = \"added\" | \"modified\" | \"removed\";\n\n/**\n * Represents the current state of a set of payments owned by a user.\n */\nexport interface PaymentSnapshot {\n  /**\n   * A list of all currently available payments ordered by the payment ID. Empty\n   * if no payments are available.\n   */\n  payments: Payment[];\n\n  /**\n   * The list of changes in the payments since the last snapshot.\n   */\n  changes: Array<{\n    type: PaymentChangeType;\n    payment: Payment;\n  }>;\n\n  /**\n   * Number of currently available payments. This is same as the length of the\n   * `payments` array in the snapshot.\n   */\n  size: number;\n\n  /**\n   * True if there are no payments available. False whenever at least one payment is\n   * present. When True, the `payments` array is empty, and the `size` is 0.\n   */\n  empty: boolean;\n}\n\n/**\n * Registers a listener to receive payment update events for the currently signed in\n * user. If the user is not signed in throws an `unauthenticated` error, and no listener is\n * registered.\n *\n * Upon successful registration, the `onUpdate` callback will fire once with\n * the current state of all the payments. From then onwards, each update to a payment\n * will fire the `onUpdate` callback with the latest state of the payments.\n *\n * @param payments - A valid {@link StripePayments} object.\n * @param onUpdate - A callback that will fire whenever the current user's payments\n *   are updated.\n * @param onError - A callback that will fire whenever an error occurs while listening to\n *   payment updates.\n * @returns A function that can be called to cancel and unregister the listener.\n */\nexport function onCurrentUserPaymentUpdate(\n  payments: StripePayments,\n  onUpdate: (snapshot: PaymentSnapshot) => void,\n  onError?: (error: StripePaymentsError) => void\n): () => void {\n  const uid: string = getCurrentUserSync(payments);\n  const dao: PaymentDAO = getOrInitPaymentDAO(payments);\n  return dao.onPaymentUpdate(uid, onUpdate, onError);\n}\n\nfunction getStatusAsArray(\n  status: PaymentStatus | PaymentStatus[]\n): PaymentStatus[] {\n  if (typeof status === \"string\") {\n    return [status];\n  }\n\n  checkNonEmptyArray(status, \"status must be a non-empty array.\");\n  return status;\n}\n\n/**\n * Internal interface for all database interactions pertaining to Stripe payments. Exported\n * for testing.\n *\n * @internal\n */\nexport interface PaymentDAO {\n  getPayment(uid: string, paymentId: string): Promise<Payment>;\n  getPayments(\n    uid: string,\n    options?: { status?: PaymentStatus[] }\n  ): Promise<Payment[]>;\n  onPaymentUpdate(\n    uid: string,\n    onUpdate: (snapshot: PaymentSnapshot) => void,\n    onError?: (error: StripePaymentsError) => void\n  ): () => void;\n}\n\nconst PAYMENT_CONVERTER: FirestoreDataConverter<Payment> = {\n  toFirestore: () => {\n    throw new Error(\"Not implemented for readonly Payment type.\");\n  },\n  fromFirestore: (snapshot: QueryDocumentSnapshot): Payment => {\n    const data: DocumentData = snapshot.data();\n    const refs: DocumentReference[] = data.prices;\n    const prices: Array<{ product: string; price: string }> = refs.map(\n      (priceRef: DocumentReference) => {\n        return {\n          product: priceRef.parent.parent!.id,\n          price: priceRef.id,\n        };\n      }\n    );\n\n    return {\n      amount: data.amount,\n      amount_capturable: data.amount_capturable,\n      amount_received: data.amount_received,\n      created: toUTCDateString(data.created),\n      currency: data.currency,\n      customer: data.customer,\n      description: data.description,\n      id: snapshot.id,\n      invoice: data.invoice,\n      metadata: data.metadata ?? {},\n      payment_method_types: data.payment_method_types,\n      prices,\n      status: data.status,\n      uid: snapshot.ref.parent.parent!.id,\n    };\n  },\n};\n\nfunction toUTCDateString(seconds: number): string {\n  const date = new Date(seconds * 1000);\n  return date.toUTCString();\n}\n\nconst PAYMENTS_COLLECTION = \"payments\" as const;\n\nclass FirestorePaymentDAO implements PaymentDAO {\n  private readonly firestore: Firestore;\n\n  constructor(app: FirebaseApp, private readonly customersCollection: string) {\n    this.firestore = getFirestore(app);\n  }\n\n  public async getPayment(uid: string, paymentId: string): Promise<Payment> {\n    const snap: QueryDocumentSnapshot<Payment> =\n      await this.getPaymentSnapshotIfExists(uid, paymentId);\n    return snap.data();\n  }\n\n  public async getPayments(\n    uid: string,\n    options?: { status?: PaymentStatus[] }\n  ): Promise<Payment[]> {\n    const querySnap: QuerySnapshot<Payment> = await this.getPaymentSnapshots(\n      uid,\n      options?.status\n    );\n    const payments: Payment[] = [];\n    querySnap.forEach((snap: QueryDocumentSnapshot<Payment>) => {\n      payments.push(snap.data());\n    });\n\n    return payments;\n  }\n\n  public onPaymentUpdate(\n    uid: string,\n    onUpdate: (snapshot: PaymentSnapshot) => void,\n    onError?: (error: StripePaymentsError) => void\n  ): () => void {\n    const payments: CollectionReference<Payment> = collection(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      PAYMENTS_COLLECTION\n    ).withConverter(PAYMENT_CONVERTER);\n    return onSnapshot(\n      payments,\n      (querySnap: QuerySnapshot<Payment>) => {\n        const snapshot: PaymentSnapshot = {\n          payments: [],\n          changes: [],\n          size: querySnap.size,\n          empty: querySnap.empty,\n        };\n        querySnap.forEach((snap: QueryDocumentSnapshot<Payment>) => {\n          snapshot.payments.push(snap.data());\n        });\n        querySnap.docChanges().forEach((change: DocumentChange<Payment>) => {\n          snapshot.changes.push({\n            type: change.type,\n            payment: change.doc.data(),\n          });\n        });\n\n        onUpdate(snapshot);\n      },\n      (err: FirestoreError) => {\n        if (onError) {\n          const arg: StripePaymentsError = new StripePaymentsError(\n            \"internal\",\n            `Error while listening to database updates: ${err.message}`,\n            err\n          );\n          onError(arg);\n        }\n      }\n    );\n  }\n\n  private async getPaymentSnapshotIfExists(\n    uid: string,\n    paymentId: string\n  ): Promise<QueryDocumentSnapshot<Payment>> {\n    const paymentRef: DocumentReference<Payment> = doc(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      PAYMENTS_COLLECTION,\n      paymentId\n    ).withConverter(PAYMENT_CONVERTER);\n    const snapshot: DocumentSnapshot<Payment> = await this.queryFirestore(() =>\n      getDoc(paymentRef)\n    );\n    if (!snapshot.exists()) {\n      throw new StripePaymentsError(\n        \"not-found\",\n        `No payment found with the ID: ${paymentId} for user: ${uid}`\n      );\n    }\n\n    return snapshot;\n  }\n\n  private async getPaymentSnapshots(\n    uid: string,\n    status?: PaymentStatus[]\n  ): Promise<QuerySnapshot<Payment>> {\n    let paymentsQuery: Query<Payment> = collection(\n      this.firestore,\n      this.customersCollection,\n      uid,\n      PAYMENTS_COLLECTION\n    ).withConverter(PAYMENT_CONVERTER);\n    if (status) {\n      paymentsQuery = query(paymentsQuery, where(\"status\", \"in\", status));\n    }\n\n    return await this.queryFirestore(() => getDocs(paymentsQuery));\n  }\n\n  private async queryFirestore<T>(fn: () => Promise<T>): Promise<T> {\n    try {\n      return await fn();\n    } catch (error) {\n      throw new StripePaymentsError(\n        \"internal\",\n        \"Unexpected error while querying Firestore\",\n        error\n      );\n    }\n  }\n}\n\nconst PAYMENT_DAO_KEY = \"payment-dao\" as const;\n\nfunction getOrInitPaymentDAO(payments: StripePayments): PaymentDAO {\n  let dao: PaymentDAO | null =\n    payments.getComponent<PaymentDAO>(PAYMENT_DAO_KEY);\n  if (!dao) {\n    dao = new FirestorePaymentDAO(payments.app, payments.customersCollection);\n    setPaymentDAO(payments, dao);\n  }\n\n  return dao;\n}\n\n/**\n * Internal API for registering a {@link PaymentDAO} instance with {@link StripePayments}.\n * Exported for testing.\n *\n * @internal\n */\nexport function setPaymentDAO(payments: StripePayments, dao: PaymentDAO): void {\n  payments.setComponent(PAYMENT_DAO_KEY, dao);\n}\n"]}